<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Regents Exams</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; max-width: 900px; }
  .question { margin-bottom: 24px; }
  .question h3 { margin-bottom: 8px; }
  .choices label { display: block; margin: 4px 0; cursor: pointer; display: flex; align-items: center; }
  input[type="text"] { width: 200px; padding: 4px; margin-right: 10px; }
  select.unit-select { padding: 4px; }
  button { margin: 10px 10px 10px 0; padding: 10px 15px; font-size: 16px; cursor: pointer; }
  #results { margin-top: 30px; font-weight: bold; white-space: pre-wrap; }
  #results .correct { color: green; }
  #results .incorrect { color: red; }
  #results .yellow { color: #d4a017; }
  #exportArea { width: 100%; height: 150px; margin-top: 20px; font-family: monospace; }
  .hidden { display: none; }
  #guidelines { margin-top: 30px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; }
  #guidelines h2 { margin-top: 0; }
  #guidelines pre { background-color: #fff; padding: 10px; border: 1px solid #ddd; border-radius: 3px; overflow-x: auto; }
  #guidelines code { font-family: monospace; }
  #errorMessage { color: red; margin-top: 10px; display: none; }

  /* Specific styles for images in questions and choices */
  .question-image {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
  }
  .choice-image {
      max-width: 80px;
      height: auto;
      margin-left: 10px;
      border: 1px solid #eee;
      border-radius: 3px;
  }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" crossorigin="anonymous" />
</head>
<body>

<h1 id="examTitle">Regents Exams</h1>

<div>
  <h2>Load an Exam:</h2>
  <label for="examSelector">Select a Regents Exam:</label>
  <select id="examSelector"></select>
  <br><br>
  <div id="errorMessage"></div>
  <button id="clearFormBtn" class="hidden">Clear Exam</button>
  <button id="toggleGuidelinesBtn">Show Guidelines</button>
</div>

<div id="guidelines" class="hidden">
  <h2>JSON Formatting Guidelines for Creating a Custom Exam</h2>
  <p>To add a new exam, first place its JSON file (e.g., <code>my_new_exam.json</code>) into the <code>quizzes/</code> folder. Then, edit the <code>exam_manifest.json</code> file (in the same directory as <code>index.html</code>) to add an entry for your new exam. Example:</p>
  <pre><code>
[
  { "name": "Existing Exam", "path": "quizzes/existing_exam.json" },
  { "name": "My New Exam", "path": "quizzes/my_new_exam.json" }
]
  </code></pre>
  <p>The JSON structure for each exam file should be as follows:</p>
  <h3>JSON Structure</h3>
  <ul>
    <li><strong>title</strong> (string): The title of the exam.</li>
    <li><strong>showQuestionNumbers</strong> (boolean): Whether to display question numbers (true/false).</li>
    <li><strong>questions</strong> (array): List of question objects.</li>
  </ul>
  <h3>Question Object</h3>
  <p>Each question object must include:</p>
  <ul>
    <li><strong>id</strong> (number): Unique identifier for the question.</li>
    <li><strong>type</strong> (string): Either <code>"multiple-choice"</code>, <code>"number"</code>, or <code>"short-answer"</code>.</li>
    <li><strong>question</strong> (string): The question text. Use LaTeX for math (e.g., <code>$x^2$</code>).</li>
    <li><strong>questionImageUrl</strong> (string, optional): Path to an image for the question (e.g., <code>"images/my_image.png"</code>).</li>
    <li><strong>questionImageAlt</strong> (string, optional): Alt text for the <code>questionImageUrl</code>.</li>
    <li><strong>choices</strong> (array, for multiple-choice only): Array of answer options. Each option can be a string, or an object with <code>"text"</code> (string) and <code>"imageUrl"</code> (string, optional, e.g., <code>{"text": "Option A", "imageUrl": "images/option_a.png"}</code>). Use LaTeX for math.</li>
    <li><strong>units</strong> (array, for number type only): Array of valid unit strings (e.g., <code>["m/s", "km/h"]</code>). Optional.</li>
    <li><strong>sigFigs</strong> (number, for number type only): Number of significant figures for answer comparison (e.g., 2). Optional; if omitted, exact value is used.</li>
    <li><strong>tolerance</strong> (number, for number type only): Absolute tolerance range for answer comparison (e.g., 0.5 for ±0.5 units, 0 for exact match). Optional; defaults to 0.001.</li>
    <li><strong>answer</strong>: The correct answer.
      <ul>
        <li>For multiple-choice: A string matching the <code>text</code> of one of the choices (e.g., <code>"$x=2$"</code>).</li>
        <li>For number: An object with <code>value</code> (number) and <code>unit</code> (string, e.g., <code>{"value": 10, "unit": "m/s"}</code>).</li>
        <li>For short-answer: A string (e.g., <code>"Paris"</code>). Compared case-insensitively.</li>
      </ul>
    </li>
  </ul>
  <h3>Example JSON (for a single exam file, like `physics_june_2022.json`)</h3>
  <pre><code>
{
  "title": "General Knowledge Exam",
  "showQuestionNumbers": true,
  "questions": [
    {
      "id": 1,
      "type": "multiple-choice",
      "question": "Which of these is a common fruit?",
      "questionImageUrl": "images/apple.png",
      "questionImageAlt": "Red apple icon",
      "choices": ["Carrot", {"text": "Apple", "imageUrl": "images/apple_small.png"}, "Broccoli", "Potato"],
      "answer": "Apple"
    },
    {
      "id": 2,
      "type": "number",
      "question": "What is the area of a circle with radius 5 cm? Give your answer to 3 significant figures.",
      "units": ["cm²", "m²"],
      "sigFigs": 3,
      "tolerance": 0,
      "answer": {"value": 78.539816, "unit": "cm²"}
    },
    {
      "id": 3,
      "type": "short-answer",
      "question": "What is the capital of France?",
      "answer": "Paris"
    }
  ]
}
  </code></pre>
  <h3>Notes</h3>
  <ul>
    <li>Use LaTeX for mathematical expressions in <code>question</code>, <code>choices</code>, and <code>answer</code> (multiple-choice) fields.</li>
    <li>Ensure <code>id</code> values are unique within the exam.</li>
    <li>For number questions, the answer's <code>unit</code> must match one of the provided <code>units</code> or be omitted if no units are specified.</li>
    <li>For number questions, answers can be entered in standard notation (e.g., <code>78.5</code>) or scientific notation (e.g., <code>7.85e1</code> or <code>7.85e+1</code>) using the text input field.</li>
    <li><code>sigFigs</code> enforces exactly the specified number of significant figures; omit for no significant figure enforcement.</li>
    <li><code>tolerance</code> specifies an absolute range (e.g., 0.5 for ±0.5 units, 0 for exact match).</li>
    <li>For short-answer questions, answers are compared case-insensitively after trimming whitespace.</li>
    <li>Invalid JSON or missing required fields will display an error message.</li>
  </ul>
</div>

<form id="testForm"></form>

<button id="submitBtn" class="hidden">Submit Answers</button>
<button id="exportBtn" class="hidden">Export Answers</button>

<div id="results"></div>
<textarea id="exportArea" class="hidden" readonly></textarea>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>

<script>
  // Render KaTeX in a container, supporting inline math inside text
  function renderMathInElementSafe(element) {
    renderMathInElement(element, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ],
      throwOnError: false
    });
  }

  const testForm = document.getElementById('testForm');
  const resultsDiv = document.getElementById('results');
  const exportArea = document.getElementById('exportArea');
  const submitBtn = document.getElementById('submitBtn');
  const exportBtn = document.getElementById('exportBtn');
  const clearFormBtn = document.getElementById('clearFormBtn');
  const toggleGuidelinesBtn = document.getElementById('toggleGuidelinesBtn');
  const errorMessage = document.getElementById('errorMessage');
  const examSelector = document.getElementById('examSelector');

  let currentTest = null;
  let availableExams = [];

  function clearForm() {
    testForm.innerHTML = '';
    resultsDiv.textContent = '';
    exportArea.value = '';
    exportArea.classList.add('hidden');
    submitBtn.classList.add('hidden');
    exportBtn.classList.add('hidden');
    clearFormBtn.classList.add('hidden');
    errorMessage.style.display = 'none';
  }

  function hasAnswers() {
    const inputs = testForm.querySelectorAll('input:checked, input[type="text"]:not([value=""]), select:not([value=""])');
    return inputs.length > 0;
  }

  function roundToSigFigs(num, sigFigs) {
    if (num === 0) return 0;
    const mag = Math.floor(Math.log10(Math.abs(num))) + 1;
    const scale = Math.pow(10, sigFigs - mag);
    return Math.round(num * scale) / scale;
  }

  function countSigFigs(numStr) {
    // Handle scientific notation
    let coefficient = numStr;
    if (/[eE][+-]?\d+$/.test(numStr)) {
      coefficient = numStr.split(/[eE]/)[0];
    }
    // Remove leading/trailing zeros, decimal point for counting
    const cleaned = coefficient.replace(/^0+|0+$/g, '').replace(/^\.|\.$/g, '');
    // Count digits, excluding decimal point
    return cleaned.replace('.', '').length;
  }

  function createQuestionElement(q, index, showNumber) {
    const container = document.createElement('div');
    container.className = 'question';

    const questionHeader = document.createElement('h3');
    questionHeader.className = 'question-text';
    questionHeader.style.whiteSpace = 'pre-wrap';
    questionHeader.innerHTML = (showNumber ? (index + 1) + '. ' : '') + q.question;
    container.appendChild(questionHeader);

    if (q.questionImageUrl) {
        const questionImage = document.createElement('img');
        questionImage.src = q.questionImageUrl;
        questionImage.alt = q.questionImageAlt || '';
        questionImage.classList.add('question-image');
        container.appendChild(questionImage);
    }

    if (q.type === 'multiple-choice') {
      const choicesDiv = document.createElement('div');
      choicesDiv.className = 'choices';

      const formattedChoices = q.choices.map(choice => {
          if (typeof choice === 'string') {
              return { text: choice, imageUrl: '' };
          }
          return choice;
      });

      formattedChoices.forEach((choice, i) => {
        const id = `q${q.id}_choice${i}`;

        const label = document.createElement('label');
        label.setAttribute('for', id);

        const input = document.createElement('input');
        input.type = 'radio';
        input.name = `q${q.id}`;
        input.id = id;
        input.value = choice.text;

        label.appendChild(input);

        const span = document.createElement('span');
        span.innerHTML = ' ' + choice.text;
        label.appendChild(span);

        if (choice.imageUrl) {
            const choiceImage = document.createElement('img');
            choiceImage.src = choice.imageUrl;
            choiceImage.alt = `Choice ${String.fromCharCode(65 + i)} image`;
            choiceImage.classList.add('choice-image');
            label.appendChild(choiceImage);
        }

        choicesDiv.appendChild(label);
      });

      container.appendChild(choicesDiv);
    } else if (q.type === 'number') {
      const input = document.createElement('input');
      input.type = 'text';
      input.name = `q${q.id}`;
      input.id = `q${q.id}_input`;
      input.placeholder = 'Enter a number';
      container.appendChild(input);

      if (Array.isArray(q.units) && q.units.length > 0) {
        const select = document.createElement('select');
        select.name = `q${q.id}_unit`;
        select.className = 'unit-select';
      
        const sortedUnits = q.units.slice().sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = '--Select Unit--';
        placeholderOption.selected = true;
        placeholderOption.disabled = true;
        select.appendChild(placeholderOption);
      
        sortedUnits.forEach(u => {
          const option = document.createElement('option');
          option.value = u;
          option.textContent = u;
          select.appendChild(option);
        });
        container.appendChild(select);
      }
    } else if (q.type === 'short-answer') {
      const input = document.createElement('input');
      input.type = 'text';
      input.name = `q${q.id}`;
      input.id = `q${q.id}_input`;
      input.placeholder = 'Enter your answer';
      container.appendChild(input);
    }

    setTimeout(() => {
      renderMathInElementSafe(container);
    }, 0);

    return container;
  }

  function validateTestData(testData) {
    if (!testData.title || typeof testData.title !== 'string') return "Missing or invalid 'title' field.";
    if (typeof testData.showQuestionNumbers !== 'boolean') return "Missing or invalid 'showQuestionNumbers' field.";
    if (!Array.isArray(testData.questions) || testData.questions.length === 0) return "Missing or empty 'questions' array.";
    
    for (let i = 0; i < testData.questions.length; i++) {
      const q = testData.questions[i];
      if (!q.id || typeof q.id !== 'number') return `Question ${i+1}: Missing or invalid 'id' field.`;
      if (!['multiple-choice', 'number', 'short-answer'].includes(q.type)) return `Question ${i+1}: Invalid 'type' field. Must be 'multiple-choice', 'number', or 'short-answer'.`;
      if (!q.question || typeof q.question !== 'string') return `Question ${i+1}: Missing or invalid 'question' field.`;
      
      if (q.questionImageUrl !== undefined && typeof q.questionImageUrl !== 'string') return `Question ${i+1}: 'questionImageUrl' must be a string if provided.`;
      if (q.questionImageAlt !== undefined && typeof q.questionImageAlt !== 'string') return `Question ${i+1}: 'questionImageAlt' must be a string if provided.`;


      if (q.type === 'multiple-choice') {
        if (!Array.isArray(q.choices) || q.choices.length === 0) return `Question ${i+1}: Missing or empty 'choices' array.`;
        for(let j=0; j<q.choices.length; j++) {
            const choice = q.choices[j];
            if (typeof choice === 'object' && choice !== null) {
                if (typeof choice.text !== 'string') return `Question ${i+1}, Choice ${j+1}: Missing or invalid 'text' in choice object.`;
                if (choice.imageUrl !== undefined && typeof choice.imageUrl !== 'string') return `Question ${i+1}, Choice ${j+1}: 'imageUrl' must be a string if provided in choice object.`;
            } else if (typeof choice !== 'string') {
                return `Question ${i+1}, Choice ${j+1}: Choice must be a string or an object with 'text' property.`;
            }
        }

        if (!q.answer || typeof q.answer !== 'string') return `Question ${i+1}: Missing or invalid 'answer' field.`;
        const choiceTexts = q.choices.map(choice => typeof choice === 'string' ? choice : choice.text);
        if (!choiceTexts.includes(q.answer)) return `Question ${i+1}: Answer "${q.answer}" does not match any choice text.`;
      } else if (q.type === 'number') {
        if (!q.answer || typeof q.answer !== 'object' || isNaN(q.answer.value)) return `Question ${i+1}: Missing or invalid 'answer' object or value.`;
        if (q.units && !Array.isArray(q.units)) return `Question ${i+1}: 'units' must be an array if provided.`;
        if (q.units && q.answer.unit && !q.units.includes(q.answer.unit)) return `Question ${i+1}: Answer unit does not match any provided unit.`;
        if (q.sigFigs !== undefined && (!Number.isInteger(q.sigFigs) || q.sigFigs <= 0)) return `Question ${i+1}: 'sigFigs' must be a positive integer if provided.`;
        if (q.tolerance !== undefined && (typeof q.tolerance !== 'number' || q.tolerance < 0)) return `Question ${i+1}: 'tolerance' must be a non-negative number if provided.`;
      } else if (q.type === 'short-answer') {
        if (!q.answer || typeof q.answer !== 'string') return `Question ${i+1}: Missing or invalid 'answer' field.`;
      }
    }
    return null;
  }

  function loadTest(testData) {
    clearForm();
    currentTest = testData;
    document.getElementById('examTitle').textContent = currentTest.title; 

    const showNumber = !!testData.showQuestionNumbers;

    testData.questions.forEach((q, i) => {
      const qElem = createQuestionElement(q, i, showNumber);
      testForm.appendChild(qElem);
    });

    submitBtn.classList.remove('hidden');
    exportBtn.classList.remove('hidden');
    clearFormBtn.classList.remove('hidden');
  }

  function checkAnswer(userAnswer, correctAnswer, type, sigFigs, tolerance = 0.001) {
    if (type === 'number') {
      if (!userAnswer || userAnswer.value === null || userAnswer.unit === null) return false;
      let userNum = Number(userAnswer.value);
      let correctNum = Number(correctAnswer.value);
      if (isNaN(userNum) || isNaN(correctNum)) return false;

      if (sigFigs !== undefined) {
        const userSigFigs = countSigFigs(userAnswer.value.toString().trim());
        if (userSigFigs !== sigFigs) return false;
        userNum = roundToSigFigs(userNum, sigFigs);
        correctNum = roundToSigFigs(correctNum, sigFigs);
      }

      const numberMatch = Math.abs(userNum - correctNum) <= tolerance;
      const unitMatch = userAnswer.unit === correctAnswer.unit;
      return numberMatch && unitMatch;
    } else if (type === 'multiple-choice') {
      if (!userAnswer) return false;
      return userAnswer.trim() === correctAnswer.trim();
    } else if (type === 'short-answer') {
      if (!userAnswer) return false;
      return userAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
    }
    return false;
  }

  function gradeTest() {
    if (!currentTest) return;

    let score = 0;
    const total = currentTest.questions.length;
    const resultsContainer = document.createElement('div');
    resultsContainer.style.whiteSpace = 'pre-wrap';

    currentTest.questions.forEach((q, i) => {
      let userAnswer;
      if (q.type === 'multiple-choice') {
        const selected = document.querySelector(`[name=q${q.id}]:checked`);
        userAnswer = selected ? selected.value : null;
      } else if (q.type === 'number') {
        const input = document.querySelector(`[name=q${q.id}]`);
        const unitSelect = document.querySelector(`[name=q${q.id}_unit]`);
        userAnswer = {
          value: input ? input.value : null,
          unit: unitSelect ? unitSelect.value : null
        };
      } else if (q.type === 'short-answer') {
        const input = document.querySelector(`[name=q${q.id}]`);
        userAnswer = input ? input.value : null;
      }

      const correct = checkAnswer(userAnswer, q.answer, q.type, q.sigFigs, q.tolerance);

      if (correct) score++;

      let yourAnswerStr = '';
      if (q.type === 'number') {
        yourAnswerStr = (userAnswer.value === '' || userAnswer.value === null) ? 'No answer' : userAnswer.value;
        yourAnswerStr += userAnswer.unit ? ` ${userAnswer.unit}` : '';
      } else {
        yourAnswerStr = userAnswer || 'No answer';
      }

      let correctAnswerStr = '';
      if (q.type === 'number') {
        const displayValue = q.sigFigs !== undefined ? roundToSigFigs(q.answer.value, q.sigFigs) : q.answer.value;
        correctAnswerStr = `${displayValue} ${q.answer.unit}`;
      } else {
        correctAnswerStr = q.answer;
      }

      const resultLine = document.createElement('div');
      resultLine.innerHTML = `Q${i + 1}: ${correct ? 'Correct' : 'Incorrect'} ` +
        `(Your answer: ${yourAnswerStr}, Correct: ${correctAnswerStr})`;
      resultLine.className = correct ? 'correct' : (q.type === 'short-answer' ? 'yellow' : 'incorrect');
      resultsContainer.appendChild(resultLine);
    });

    const scoreLine = document.createElement('div');
    scoreLine.textContent = `Your score: ${score} / ${total} (${((score/total)*100).toFixed(1)}%)`;
    resultsContainer.insertBefore(scoreLine, resultsContainer.firstChild);

    resultsDiv.innerHTML = '';
    resultsDiv.appendChild(resultsContainer);

    setTimeout(() => {
      renderMathInElementSafe(resultsContainer);
    }, 0);
  }

  function exportAnswers() {
    if (!currentTest) return;

    const answers = {};

    currentTest.questions.forEach(q => {
      if (q.type === 'multiple-choice') {
        const selected = document.querySelector(`[name=q${q.id}]:checked`);
        answers[`q${q.id}`] = selected ? selected.value : null;
      } else if (q.type === 'number') {
        const input = document.querySelector(`[name=q${q.id}]`);
        const unitSelect = document.querySelector(`[name=q${q.id}_unit]`);
        if (input) {
          answers[`q${q.id}`] = {
            value: input.value || null,
            unit: unitSelect ? unitSelect.value : null
          };
        } else {
          answers[`q${q.id}`] = null;
        }
      } else if (q.type === 'short-answer') {
        const input = document.querySelector(`[name=q${q.id}]`);
        answers[`q${q.id}`] = input ? input.value : null;
      }
    });

    exportArea.value = JSON.stringify(answers, null, 2);
    exportArea.classList.remove('hidden');
  }

  async function loadExamFromFile(filePath) {
      errorMessage.style.display = 'none'; // Hide previous errors
      try {
          const response = await fetch(filePath);
          if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status} - Could not load "${filePath}"`);
          }
          const testData = await response.json();
          const validationError = validateTestData(testData);
          if (validationError) {
              errorMessage.textContent = `Error in "${filePath}": ${validationError}`;
              errorMessage.style.display = 'block';
              // If validation fails, attempt to reset selector to currently loaded exam
              const currentExamPath = currentTest ? availableExams.find(e => e.name === currentTest.title)?.path : '';
              examSelector.value = currentExamPath || (availableExams.length > 0 ? availableExams[0].path : '');
              return;
          }
          if (hasAnswers() && !confirm('Loading a new exam will clear your current answers. Continue?')) {
              // If user cancels, reset selector to previously loaded exam
              const currentExamPath = currentTest ? availableExams.find(e => e.name === currentTest.title)?.path : '';
              examSelector.value = currentExamPath || (availableExams.length > 0 ? availableExams[0].path : '');
              return;
          }
          loadTest(testData);
      } catch (e) {
          errorMessage.textContent = `Failed to load exam from ${filePath}: ${e.message}`;
          errorMessage.style.display = 'block';
          // On error, reset the selector to the currently loaded exam
          const currentExamPath = currentTest ? availableExams.find(e => e.name === currentTest.title)?.path : '';
          examSelector.value = currentExamPath || (availableExams.length > 0 ? availableExams[0].path : '');
      }
  }

  // Function to initialize exams from manifest
  async function initializeExams() {
    try {
      const response = await fetch('exam_manifest.json');
      if (!response.ok) {
        throw new Error(`Failed to load exam manifest: ${response.status}`);
      }
      availableExams = await response.json();

      // Populate the exam selector dropdown
      examSelector.innerHTML = ''; // Clear existing options
      availableExams.forEach(exam => {
        const option = document.createElement('option');
        option.value = exam.path;
        option.textContent = exam.name;
        examSelector.appendChild(option);
      });

      // Load the first exam in the list by default
      if (availableExams.length > 0) {
        examSelector.value = availableExams[0].path;
        loadExamFromFile(availableExams[0].path);
      } else {
        errorMessage.textContent = 'No exams found in exam_manifest.json. Please add some exam entries.';
        errorMessage.style.display = 'block';
      }
    } catch (e) {
      errorMessage.textContent = `Error initializing exams: ${e.message}. Make sure exam_manifest.json exists and is valid.`;
      errorMessage.style.display = 'block';
      console.error(e);
    }
  }


  window.addEventListener('load', () => {
    initializeExams();

    setTimeout(() => {
      renderMathInElementSafe(document.getElementById('guidelines'));
    }, 0);
  });

  // Event listener for exam selector change
  examSelector.addEventListener('change', (event) => {
      const selectedFilePath = event.target.value;
      if (selectedFilePath) {
          loadExamFromFile(selectedFilePath);
      }
  });

  clearFormBtn.addEventListener('click', () => {
    if (hasAnswers() && !confirm('Clearing the exam will reset all answers. Continue?')) {
      return;
    }
    clearForm();
    // After clearing, reload the initially loaded exam
    if (availableExams.length > 0) {
        examSelector.value = availableExams[0].path;
        loadExamFromFile(availableExams[0].path);
    }
  });

  toggleGuidelinesBtn.addEventListener('click', () => {
    const guidelines = document.getElementById('guidelines');
    const isHidden = guidelines.classList.contains('hidden');
    guidelines.classList.toggle('hidden');
    toggleGuidelinesBtn.textContent = isHidden ? 'Hide Guidelines' : 'Show Guidelines';
    if (!isHidden) {
      setTimeout(() => {
        renderMathInElementSafe(guidelines);
      }, 0);
    }
  });

  submitBtn.addEventListener('click', e => {
    e.preventDefault();
    gradeTest();
  });

  exportBtn.addEventListener('click', e => {
    e.preventDefault();
    exportAnswers();
  });

</script>

</body>
</html>
